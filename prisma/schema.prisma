
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Tenant {
  id                  String        @id @default(cuid())
  name                String
  subdomain           String        @unique // e.g., mycompany.example.com
  logoUrl             String?
  primaryColor        String?
  secondaryColor      String?
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
  users               TenantUser[]
  roles               Role[] // Roles specific to this tenant
  permissions         Permission[] // Permissions defined within this tenant (could also be global)
  apiKeys             ApiKey[]
  // CRM Entities
  leads               Lead[]
  contacts            Contact[]
  companies           Company[]
  opportunities       Opportunity[]
  products            Product[]
  quotes              Quote[]
  tasks               Task[]
  projects            Project[]
  // Chat & Flow Entities
  conversations       Conversation[]
  messages            Message[]
  chatbotFlows        ChatbotFlow[]
  chatMessages        ChatMessage[]
  rolePermissions     RolePermission[]

  deletedAt           DateTime? // Soft delete for tenants if needed

  @@index([subdomain])
}


model TenantUser {
  id                      String         @id @default(cuid())
  supabaseAuthUserId      String         @unique // Link to Supabase Auth user ID
  email                   String         @unique
  fullName                String?
  avatarUrl               String?
  roleId                  String // ID of the Role within this tenant
  role                    Role           @relation(fields: [roleId], references: [id])
  tenantId                String
  tenant                  Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt               DateTime       @default(now())
  updatedAt               DateTime       @updatedAt
  sessions                UserSession[]
  notifications           Notification[] @relation("NotificationToUser")
  assignedConversations   Conversation[] @relation("AssignedConversationToUser")
  assignedTasks           Task[]         @relation("TaskAssignedToUser")
  assignedOpportunities   Opportunity[]  @relation("OpportunityAssignedToUser")
  createdQuotes           Quote[]        @relation("QuoteCreatedByUser")

  deletedAt               DateTime?

  @@unique([tenantId, email])
  @@index([tenantId])
  @@index([roleId])
}

model Role {
  id                String    @id @default(cuid())
  name              String // e.g., Administrator, Agent, Supervisor
  description       String?
  isSystemRole      Boolean   @default(false) // True for predefined system roles, false for tenant-custom roles
  tenantId          String
  tenant            Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  users             TenantUser[] // Users having this role (inverse of TenantUser.role)
  rolePermissions   RolePermission[] // Permissions associated with this role
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  deletedAt         DateTime?

  @@unique([tenantId, name]) // Role names must be unique within a tenant
  @@index([tenantId])
}

model Permission {
  id                String   @id @default(cuid())
  action            String // e.g., create, read, update, delete, assign, manage_billing
  resource          String // e.g., lead, conversation, user, settings, all
  description       String?
  tenantId          String // Permissions can be tenant-specific if needed, or global
  tenant            Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  rolePermissions   RolePermission[] // Roles that include this permission
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  deletedAt         DateTime?

  @@unique([tenantId, action, resource])
  @@index([tenantId])
}

model RolePermission {
  roleId          String
  permissionId    String
  tenantId        String     // To ensure the join is within the same tenant context
  assignedAt      DateTime   @default(now())

  role            Role       @relation(fields: [roleId, tenantId], references: [id, tenantId], onDelete: Cascade)
  permission      Permission @relation(fields: [permissionId, tenantId], references: [id, tenantId], onDelete: Cascade)
  tenant          Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId, tenantId]) // Composite key for the join table
  @@index([tenantId])
}


model ApiKey {
  id          String   @id @default(cuid())
  keyHash     String   @unique // Store a hash of the API key, not the key itself
  name        String
  prefix      String   @unique // First few characters of the key for identification
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  expiresAt   DateTime?
  lastUsedAt  DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  deletedAt DateTime?
  
  @@index([tenantId])
}

model UserSession {
  id        String     @id @default(cuid())
  userId    String
  user      TenantUser @relation(fields: [userId], references: [id], onDelete: Cascade)
  ipAddress String?
  userAgent String?
  expiresAt DateTime
  createdAt DateTime   @default(now())

  @@index([userId])
}

enum NotificationType {
  NEW_LEAD
  TASK_REMINDER
  MENTION
  SYSTEM_UPDATE
  QUOTE_STATUS_CHANGE
}

model Notification {
  id          String           @id @default(cuid())
  type        NotificationType
  title       String
  message     String
  link        String?
  isRead      Boolean          @default(false)
  userId      String // Recipient user
  user        TenantUser       @relation("NotificationToUser", fields: [userId], references: [id], onDelete: Cascade)
  tenantId    String
  // tenant      Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade) // Redundant if linked via User
  createdAt   DateTime         @default(now())

  deletedAt   DateTime?

  @@index([userId])
  @@index([tenantId])
}

enum ChannelType {
  WHATSAPP
  MESSENGER
  INSTAGRAM
  WEBCHAT // Corrected from WEB_CHAT
  TELEGRAM
  API
}

enum ConversationStatus {
  ACTIVE // Unassigned, new, or ongoing
  ASSIGNED // Assigned to a specific agent
  CLOSED // Resolved or intentionally closed
  ARCHIVED // Archived by an agent or system
  // Removed: PENDING, RESOLVED, BOT, AGENT -> Simplified
}

model Conversation {
  id                 String             @id @default(cuid())
  channel            ChannelType
  channelConversationId String?         @unique // ID from the external channel (e.g., WhatsApp message ID)
  status             ConversationStatus @default(ACTIVE)
  userName           String?            // Name of the user/contact in the conversation
  userAvatarUrl      String?
  lastMessageSnippet String?
  unreadCount        Int                @default(0)
  assignedToUserId   String?
  assignedTo         TenantUser?        @relation("AssignedConversationToUser", fields: [assignedToUserId], references: [id], onDelete: SetNull)
  tenantId           String
  tenant             Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade) // Ensures conversations are deleted if tenant is
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  messages           Message[]
  leadId             String?
  lead               Lead?              @relation(fields: [leadId], references: [id], onDelete: SetNull)

  deletedAt          DateTime?

  @@index([tenantId])
  @@index([assignedToUserId])
  @@index([leadId])
}

enum MessageSender {
  USER
  AGENT
  SYSTEM
  BOT
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  FILE
  PRODUCT_INFO // e.g. for sending a product card
  INTERACTIVE_BUTTON_REPLY
  INTERACTIVE_LIST_REPLY
  // Removed: CAROUSEL, INTERACTIVE_BUTTONS, INTERACTIVE_LIST
}

model Message {
  id             String        @id @default(cuid())
  conversationId String
  conversation   Conversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderType     MessageSender
  senderId       String?       // Can be TenantUser.id or external contact ID
  content        String?       // For text messages
  mediaUrl       String?       // For images, videos, audio, files
  mediaMimeType  String?
  messageType    MessageType   @default(TEXT)
  timestamp      DateTime      @default(now())
  tenantId       String
  tenant         Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt      DateTime      @default(now())
  // Rich message properties (optional)
  productName        String?
  productDescription String?
  productPrice       String?
  buttonsJson        String? // Store buttons as JSON string: [{"label": "A", "payload": "pa"}, {"label": "B", "payload": "pb"}]
  listItemsJson      String? // Store list items as JSON string: [{"title": "T1", "desc": "D1", "payload": "pl1"}]
  
  deletedAt DateTime?

  @@index([conversationId])
  @@index([tenantId])
}

// CRM Entities

enum LeadSource {
  WHATSAPP
  WEB_CHAT
  MESSENGER
  INSTAGRAM
  MANUAL
  REFERRAL
  API
  OTHER
}

enum LeadStatus {
  NEW
  CONTACTED
  QUALIFIED
  PROPOSAL
  NEGOTIATION
  CONVERTED // Converted to Opportunity or Customer
  CLOSED_WON // If lead directly becomes a sale without explicit Opportunity
  CLOSED_LOST
  UNQUALIFIED
}

model Lead {
  id                String        @id @default(cuid())
  name              String
  email             String?       @unique // Optional but unique if provided
  phone             String?
  source            LeadSource    @default(MANUAL)
  status            LeadStatus    @default(NEW)
  assignedToUserId  String?
  assignedTo        TenantUser?   @relation("OpportunityAssignedToUser", fields: [assignedToUserId], references: [id], onDelete: SetNull) // Re-using for leads
  lastContacted     DateTime?
  companyId         String?
  company           Company?      @relation(fields: [companyId], references: [id], onDelete: SetNull)
  notes             String?
  tenantId          String
  tenant            Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  conversations     Conversation[]
  opportunities     Opportunity[]
  tags              LeadTag[]

  deletedAt         DateTime?

  @@index([tenantId])
  @@index([assignedToUserId])
  @@index([companyId])
}

model Tag {
  id        String    @id @default(cuid())
  name      String
  tenantId  String
  tenant    Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  leadTags  LeadTag[]
  taskTags  TaskTag[]
  projectTags ProjectTag[]
  
  deletedAt DateTime?

  @@unique([tenantId, name])
  @@index([tenantId])
}

model LeadTag {
  leadId    String
  tagId     String
  tenantId  String // Ensure consistency if tags are tenant-specific
  lead      Lead     @relation(fields: [leadId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  // tenant Tenant @relation(fields: [tenantId], references: [id]) // Optional if Tag already has tenantId

  @@id([leadId, tagId])
  // @@index([tenantId])
}

model Company {
  id                String        @id @default(cuid())
  name              String
  email             String?       @unique // Optional but unique if provided
  phone             String?
  website           String?
  addressStreet     String?
  addressCity       String?
  addressState      String?
  addressPostalCode String?
  addressCountry    String?
  description       String?
  industry          String?
  annualRevenue     Float?
  numberOfEmployees Int?
  tenantId          String
  tenant            Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  leads             Lead[]
  contacts          Contact[]
  opportunities     Opportunity[]
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  deletedAt         DateTime?

  @@index([tenantId])
}

model Contact {
  id          String        @id @default(cuid())
  firstName   String
  lastName    String?
  email       String?       @unique
  phone       String?
  companyId   String?
  company     Company?      @relation(fields: [companyId], references: [id], onDelete: SetNull)
  tenantId    String
  tenant      Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  
  deletedAt   DateTime?

  @@index([tenantId])
  @@index([companyId])
}

enum OpportunityStage {
  QUALIFICATION
  PROPOSAL
  NEGOTIATION
  CLOSED_WON
  CLOSED_LOST
}

model Opportunity {
  id               String           @id @default(cuid())
  name             String
  stage            OpportunityStage @default(QUALIFICATION)
  amount           Float?
  closeDate        DateTime?
  leadId           String?          // Link to the originating lead
  lead             Lead?            @relation(fields: [leadId], references: [id], onDelete: SetNull)
  companyId        String?          // Link to the company, if applicable
  company          Company?         @relation(fields: [companyId], references: [id], onDelete: SetNull)
  assignedToUserId String?
  assignedTo       TenantUser?      @relation("OpportunityAssignedToUser", fields: [assignedToUserId], references: [id], onDelete: SetNull)
  tenantId         String
  tenant           Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  products         OpportunityProduct[]
  quotes           Quote[]          @relation("QuoteForOpportunity")

  deletedAt        DateTime?

  @@index([tenantId])
  @@index([leadId])
  @@index([companyId])
  @@index([assignedToUserId])
}

enum ProductType {
  PRODUCTO
  SERVICIO
}

model Product {
  id                String             @id @default(cuid())
  name              String
  type              ProductType        @default(PRODUCTO) // PRODUCTO, SERVICIO
  description       String?
  price             Float
  sku               String?            @unique
  category          String?
  isActive          Boolean            @default(true)
  tenantId          String
  tenant            Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  opportunities     OpportunityProduct[]
  quoteLineItems    QuoteLineItem[]
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  deletedAt         DateTime?

  @@index([tenantId])
}

model OpportunityProduct {
  opportunityId String
  productId     String
  quantity      Int      @default(1)
  unitPrice     Float    // Price at the time of adding to opportunity
  total         Float    // quantity * unitPrice
  opportunity   Opportunity @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  product       Product     @relation(fields: [productId], references: [id], onDelete:Restrict) // Don't delete product if in opp
  tenantId      String
  // tenant        Tenant      @relation(fields: [tenantId], references: [id]) // Implicit via Opportunity

  @@id([opportunityId, productId])
  // @@index([tenantId])
}

enum QuoteStatus {
  DRAFT
  SENT
  ACCEPTED
  REJECTED
  EXPIRED
  CANCELED
}

model Quote {
  id                String      @id @default(cuid())
  quoteNumber       String      @unique // Tenant-wide unique or prefix-based
  opportunityId     String
  opportunity       Opportunity @relation("QuoteForOpportunity", fields: [opportunityId], references: [id], onDelete: Cascade)
  createdById       String?     // User who created the quote
  createdBy         TenantUser? @relation("QuoteCreatedByUser", fields: [createdById], references: [id], onDelete: SetNull)
  dateCreated       DateTime    @default(now())
  expiryDate        DateTime?
  status            QuoteStatus @default(DRAFT)
  totalAmount       Float
  tenantId          String
  tenant            Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  lineItems         QuoteLineItem[]
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  deletedAt         DateTime?
  
  @@index([tenantId])
  @@index([opportunityId])
  @@index([createdById])
}

model QuoteLineItem {
  id          String   @id @default(cuid())
  quoteId     String
  quote       Quote    @relation(fields: [quoteId], references: [id], onDelete: Cascade)
  productId   String
  product     Product  @relation(fields: [productId], references: [id], onDelete: Restrict) // Prevent product deletion if in a quote
  productName String   // Snapshot of product name at time of quote
  quantity    Int
  unitPrice   Float    // Snapshot of unit price
  total       Float    // quantity * unitPrice
  tenantId    String
  // tenant   Tenant   @relation(fields: [tenantId], references: [id]) // Implicit via Quote

  @@index([quoteId])
  @@index([productId])
  // @@index([tenantId])
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  ARCHIVED
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
}

model Task {
  id               String        @id @default(cuid())
  title            String
  description      String?
  status           TaskStatus    @default(PENDING)
  dueDate          DateTime?
  priority         TaskPriority? @default(MEDIUM)
  assignedToUserId String?
  assignedTo       TenantUser?   @relation("TaskAssignedToUser", fields: [assignedToUserId], references: [id], onDelete: SetNull)
  opportunityId    String?       // Optional: Link task to an opportunity
  opportunity      Opportunity?  @relation(fields: [opportunityId], references: [id], onDelete: SetNull)
  projectId        String?       // Optional: Link task to a project
  project          Project?      @relation(fields: [projectId], references: [id], onDelete: SetNull)
  tenantId         String
  tenant           Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  tags             TaskTag[]

  deletedAt        DateTime?

  @@index([tenantId])
  @@index([assignedToUserId])
  @@index([opportunityId])
  @@index([projectId])
}

model TaskTag {
  taskId   String
  tagId    String
  tenantId String
  task     Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  tag      Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  // tenant Tenant @relation(fields: [tenantId], references: [id]) // Implicit

  @@id([taskId, tagId])
  // @@index([tenantId])
}

enum ProjectStatus {
  PLANNING
  ACTIVE
  COMPLETED
  ON_HOLD
  CANCELED
}

model Project {
  id              String             @id @default(cuid())
  name            String
  description     String?
  status          ProjectStatus      @default(PLANNING)
  clientName      String?            // Could be a Company ID or just text
  progress        Int?               @default(0) // Percentage 0-100
  deadline        DateTime?
  opportunityId   String?            @unique // A project might originate from one opportunity
  opportunity     Opportunity?       @relation(fields: [opportunityId], references: [id], onDelete: SetNull)
  tenantId        String
  tenant          Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt
  tasks           Task[]
  tags            ProjectTag[]
  teamMembers     ProjectTeamMember[]

  deletedAt       DateTime?

  @@index([tenantId])
}

model ProjectTag {
  projectId String
  tagId     String
  tenantId  String
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  // tenant    Tenant   @relation(fields: [tenantId], references: [id])

  @@id([projectId, tagId])
  // @@index([tenantId])
}

model ProjectTeamMember {
  projectId    String
  tenantUserId String // ID of TenantUser
  project      Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  tenantUser   TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade) // Ensure this relation is defined
  tenantId     String
  // tenant    Tenant   @relation(fields: [tenantId], references: [id])

  @@id([projectId, tenantUserId])
  // @@index([tenantId])
}

// Chatbot Flow Entities
model ChatbotFlow {
  id             String        @id @default(cuid())
  name           String
  description    String?
  flowDefinition Json          // JSON object defining the flow (nodes, edges, etc.)
  status         String        @default("DRAFT") // DRAFT, PUBLISHED, ARCHIVED
  tenantId       String
  tenant         Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  
  deletedAt      DateTime?

  @@index([tenantId])
}

// For Website Chat SDK message history (potentially different from main Conversation messages)
model ChatMessage {
  id              String   @id @default(cuid())
  sessionId       String   // Unique session ID for a website visitor
  sender          String   // "user" or "bot"
  message         String
  timestamp       DateTime @default(now())
  flowId          String?  // If linked to a specific flow
  chatbotFlow     ChatbotFlow? @relation(fields: [flowId], references: [id], onDelete: SetNull)
  tenantId        String
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  deletedAt       DateTime?

  @@index([sessionId])
  @@index([tenantId])
}

// Additional Enums based on previous context
enum FlowNodeDataType {
  START
  END
  MESSAGE_TEXT
  MESSAGE_IMAGE
  MESSAGE_VIDEO
  MESSAGE_AUDIO
  MESSAGE_FILE
  MESSAGE_CAROUSEL
  MESSAGE_LIST
  MESSAGE_BUTTONS
  USER_INPUT
  CONDITION
  API_CALL
  SET_VARIABLE
  ASSIGN_AGENT
  ADD_TAG
  CUSTOM_ACTION
}

    