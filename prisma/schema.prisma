// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // directUrl = env("DIRECT_URL")
}

// TENANT AND USER MANAGEMENT
model Tenant {
  id             String    @id @default(uuid())
  name           String
  subdomain      String    @unique // e.g., mycompany for mycompany.example.com
  logoUrl        String?
  primaryColor   String?
  secondaryColor String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  deletedAt      DateTime?

  users           TenantUser[]
  roles           Role[]
  permissions     Permission[] // Permissions defined by this tenant (if tenant-specific permissions)
  conversations   Conversation[]
  messages        Message[]
  leads           Lead[]
  tags            Tag[]
  contacts        Contact[]
  opportunities   Opportunity[]
  products        Product[]
  quotes          Quote[]
  tasks           Task[]
  projects        Project[]
  chatbotFlows    ChatbotFlow[]
  rolePermissions RolePermission[]
  userSessions    UserSession[]
  notifications   Notification[]
  companies       Company[]

  @@index([subdomain])
}

model TenantUser {
  id        String    @id @default(uuid())
  userId    String // Corresponds to Supabase Auth User ID
  tenantId  String
  roleId    String // ID of the role within this tenant
  email     String // Denormalized for easier access, should be kept in sync with Supabase Auth
  fullName  String?
  avatarUrl String?
  isActive  Boolean   @default(true)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  tenant                Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  role                  Role                @relation(fields: [roleId], references: [id])
  userSessions          UserSession[]
  notifications         Notification[]      @relation("NotificationToUser")
  assignedConversations Conversation[]      @relation("AssignedConversationToUser")
  assignedLeads         Lead[]              @relation("LeadAssignedToUser")
  assignedOpportunities Opportunity[]       @relation("OpportunityAssignedToUser")
  createdTasks          Task[]              @relation("TaskCreatedByUser")
  assignedTasks         Task[]              @relation("TaskAssignedToUser")
  ProjectTeamMember     ProjectTeamMember[]
  createdQuotes         Quote[]             @relation("QuoteCreatedByUser")
  // Lead                 Lead[] // This was the original problematic line

  @@unique([userId, tenantId]) // A user is unique per tenant
  @@unique([email, tenantId]) // Email is unique per tenant for invites/logins
  @@index([tenantId])
  @@index([roleId])
}

model Role {
  id           String    @id @default(uuid())
  tenantId     String
  name         String // e.g., Administrator, Agent, Supervisor
  description  String?
  isSystemRole Boolean   @default(false) // True for predefined roles, false for tenant-custom roles
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  deletedAt    DateTime?

  tenant          Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  users           TenantUser[] // Users having this role
  rolePermissions RolePermission[]

  @@unique([tenantId, name])
  @@index([tenantId])
}

model Permission {
  id          String    @id @default(uuid())
  tenantId    String? // Nullable if global, or set if tenant-specific permission definition
  action      String // e.g., CREATE, READ, UPDATE, DELETE, ASSIGN_CONVERSATION, VIEW_ANALYTICS
  resource    String // e.g., LEAD, CONVERSATION, USER, SETTINGS_BILLING
  description String?
  isGlobal    Boolean   @default(false) // True if this permission is a system-level one
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  tenant          Tenant?          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  rolePermissions RolePermission[]

  @@unique([action, resource, tenantId]) // Ensures a permission is unique within a tenant or globally if tenantId is null
  @@index([tenantId])
}

// Joins Role and Permission (Many-to-Many)
model RolePermission {
  roleId       String
  permissionId String
  tenantId     String // To scope this assignment to the tenant
  assignedAt   DateTime @default(now())

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId, tenantId])
  @@index([tenantId])
}

model UserSession {
  id           String     @id @default(uuid())
  tenantUserId String
  expiresAt    DateTime
  createdAt    DateTime   @default(now())
  tenantUser   TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
  tenantId     String // For easier querying per tenant
  Tenant       Tenant     @relation(fields: [tenantId], references: [id])

  @@index([tenantUserId])
  @@index([expiresAt])
  @@index([tenantId])
}

// NOTIFICATIONS
model Notification {
  id              String    @id @default(uuid())
  tenantUserId    String // User receiving the notification
  title           String
  message         String
  link            String? // Link to the relevant item (e.g., conversation, task)
  isRead          Boolean   @default(false)
  type            String? // e.g., MENTION, ASSIGNMENT, ALERT
  relatedEntityId String? // ID of the entity this notification relates to (e.g., conversation ID)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime?

  recipient TenantUser @relation("NotificationToUser", fields: [tenantUserId], references: [id], onDelete: Cascade)
  tenantId  String
  Tenant    Tenant     @relation(fields: [tenantId], references: [id])

  @@index([tenantUserId])
  @@index([tenantId])
}

// CONVERSATION MODULE
enum ChannelType {
  WHATSAPP
  MESSENGER
  INSTAGRAM
  WEBCHAT // Renamed from WEB_CHAT for consistency if desired, or keep WEB_CHAT
  TELEGRAM
  API
  MANUAL // For manually created conversations
}

enum ConversationStatus {
  ACTIVE // Open and needs attention
  ASSIGNED // Assigned to an agent but may still be active
  CLOSED // Resolved
  ARCHIVED // Closed and archived, not in active lists
  NEW // New lead/conversation, not yet contacted or qualified
  CONTACTED
  QUALIFIED
  PROPOSAL
  NEGOTIATION
  CONVERTED // e.g. to Opportunity or Sale
  CLOSED_WON
  CLOSED_LOST
  UNQUALIFIED
}

model Conversation {
  id                 String             @id @default(uuid())
  channel            ChannelType
  channelSpecificId  String? // e.g., WhatsApp chat ID, Messenger thread ID
  status             ConversationStatus @default(ACTIVE)
  lastMessageSnippet String?
  lastMessageAt      DateTime?
  unreadCount        Int                @default(0)
  assignedToUserId   String?
  tenantId           String
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  deletedAt          DateTime?

  assignedTo TenantUser? @relation("AssignedConversationToUser", fields: [assignedToUserId], references: [id], onDelete: SetNull)
  tenant     Tenant      @relation(fields: [tenantId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  messages   Message[]
  leadId     String?
  lead       Lead?       @relation(fields: [leadId], references: [id], onDelete: SetNull) // Link to Lead

  @@index([tenantId, status, lastMessageAt])
  @@index([assignedToUserId])
  @@index([leadId])
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  FILE
  PRODUCT
  LOCATION
  CONTACT_CARD
  STICKER
  TEMPLATE // For WhatsApp templates
  INTERACTIVE_BUTTON_REPLY // User clicked a button
  INTERACTIVE_LIST_REPLY // User selected from a list
  SYSTEM // System generated messages (e.g., "Agent joined", "Conversation closed")
}

enum MessageSenderType {
  USER // End-user/customer
  AGENT
  BOT
  SYSTEM
}

model Message {
  id              String            @id @default(uuid())
  conversationId  String
  senderType      MessageSenderType
  senderId        String? // ID of the TenantUser if senderType is AGENT or BOT, or customer's channel ID
  content         String? // Text content
  type            MessageType       @default(TEXT)
  timestamp       DateTime          @default(now()) // When the message was received/sent by the system
  mediaUrl        String? // URL for image, video, audio, file
  fileName        String?
  fileSize        Int?
  caption         String? // For media
  interactiveData Json? // For buttons, lists, product messages (JSON structure)
  metadata        Json? // Any other metadata, reactions, read receipts
  aiGenerated     Boolean           @default(false) // Was this message (e.g. agent reply) AI assisted/generated
  tenantId        String
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  deletedAt       DateTime?

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  tenant       Tenant       @relation(fields: [tenantId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@index([conversationId, timestamp])
  @@index([tenantId])
}

// CRM MODULES

// Lead
model Lead {
  id               String             @id @default(uuid())
  tenantId         String
  name             String
  email            String?            @unique // Email should ideally be unique per tenant for a lead
  phone            String?
  source           String? // e.g., WhatsApp, Web Form, Manual Entry
  status           ConversationStatus @default(NEW) // Using ConversationStatus enum for lead lifecycle
  assignedToUserId String?
  lastContacted    DateTime?
  companyName      String? // Denormalized for quick view, or link to Company model
  notes            String?
  tags             LeadTag[] // Many-to-many with Tag
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  deletedAt        DateTime?

  tenant        Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  assignedTo    TenantUser?    @relation("LeadAssignedToUser", fields: [assignedToUserId], references: [id], onDelete: SetNull)
  conversations Conversation[] // Conversations associated with this lead
  opportunities Opportunity[] // Opportunities derived from this lead
  companyId     String?
  company       Company?       @relation(fields: [companyId], references: [id])
  Contact       Contact[]

  @@index([tenantId, status])
  @@index([tenantId, email])
  @@index([assignedToUserId])
  @@index([companyId])
}

// Tag (for Leads, Opportunities, etc.)
model Tag {
  id        String    @id @default(uuid())
  tenantId  String
  name      String // Tag name, e.g., "VIP", "Follow Up Q3", "Competitor"
  color     String? // Hex color for the tag
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  tenant     Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  leads      LeadTag[]
  tasks      TaskTag[]
  ProjectTag ProjectTag[]

  @@unique([tenantId, name])
  @@index([tenantId])
}

model LeadTag {
  leadId     String
  tagId      String
  assignedAt DateTime @default(now())

  lead Lead @relation(fields: [leadId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([leadId, tagId])
}

// Company
model Company {
  id                String    @id @default(uuid())
  tenantId          String
  name              String
  email             String?   @unique // Company general email
  phone             String?
  website           String?
  addressStreet     String?
  addressCity       String?
  addressState      String?
  addressPostalCode String?
  addressCountry    String?
  description       String?
  industry          String?
  annualRevenue     Float?
  numberOfEmployees Int?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  deletedAt         DateTime?

  tenant        Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  leads         Lead[] // Leads associated with this company
  contacts      Contact[] // Contacts associated with this company
  opportunities Opportunity[] // Opportunities with this company
  Project       Project[]

  @@index([tenantId, name])
}

// Contact (People associated with Leads/Companies/Opportunities)
model Contact {
  id          String    @id @default(uuid())
  tenantId    String
  name        String
  email       String?   @unique // Contact's personal or work email
  phone       String?
  mobilePhone String?
  jobTitle    String?
  companyId   String? // Link to Company
  leadId      String? // Link to Lead if this contact originated from a lead
  notes       String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  tenant        Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  company       Company?             @relation(fields: [companyId], references: [id], onDelete: SetNull)
  lead          Lead?                @relation(fields: [leadId], references: [id], onDelete: SetNull)
  opportunities OpportunityContact[]

  @@index([tenantId, email])
  @@index([companyId])
  @@index([leadId])
}

// Opportunity
enum OpportunityStatus {
  QUALIFICATION
  PROPOSAL_SENT
  NEGOTIATION
  CLOSED_WON
  CLOSED_LOST
  ON_HOLD
}

model Opportunity {
  id                String            @id @default(uuid())
  tenantId          String
  name              String // e.g., "Website Redesign for Acme Corp"
  leadId            String? // Original lead this opportunity came from
  companyId         String? // Company this opportunity is for
  amount            Float? // Estimated or actual deal amount
  status            OpportunityStatus @default(QUALIFICATION)
  expectedCloseDate DateTime?
  actualCloseDate   DateTime?
  assignedToUserId  String?
  notes             String?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  deletedAt         DateTime?

  tenant     Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  lead       Lead?                @relation(fields: [leadId], references: [id], onDelete: SetNull)
  company    Company?             @relation(fields: [companyId], references: [id], onDelete: SetNull)
  assignedTo TenantUser?          @relation("OpportunityAssignedToUser", fields: [assignedToUserId], references: [id], onDelete: SetNull)
  products   OpportunityProduct[]
  quotes     Quote[]
  tasks      Task[]               @relation("TaskForOpportunity")
  contacts   OpportunityContact[]
  projects   Project[] // Projects resulting from this opportunity

  @@index([tenantId, status])
  @@index([leadId])
  @@index([companyId])
  @@index([assignedToUserId])
}

// Product/Service
enum ProductType {
  PRODUCTO
  SERVICIO
}

model Product {
  id          String      @id @default(uuid())
  tenantId    String
  name        String
  type        ProductType @default(PRODUCTO) // PRODUCTO, SERVICIO
  description String?
  price       Float
  sku         String? // Stock Keeping Unit, relevant for PRODUCTO
  category    String?
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  deletedAt   DateTime?

  tenant              Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  opportunityProducts OpportunityProduct[]
  quoteLineItems      QuoteLineItem[]

  @@unique([tenantId, sku])
  @@index([tenantId, name])
  @@index([tenantId, type])
}

// Link table for Opportunity and Product (Many-to-Many)
model OpportunityProduct {
  opportunityId String
  productId     String
  quantity      Int      @default(1)
  unitPrice     Float // Price at the time of adding to opportunity, can differ from Product.price
  totalPrice    Float // quantity * unitPrice
  notes         String?
  createdAt     DateTime @default(now())

  opportunity Opportunity @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  product     Product     @relation(fields: [productId], references: [id], onDelete: Restrict) // Restrict deletion of product if in use

  @@id([opportunityId, productId])
}

// Link table for Opportunity and Contact (Many-to-Many)
model OpportunityContact {
  opportunityId     String
  contactId         String
  roleInOpportunity String? // e.g., Decision Maker, Influencer
  assignedAt        DateTime @default(now())

  opportunity Opportunity @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  contact     Contact     @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@id([opportunityId, contactId])
}

// Quote
enum QuoteStatus {
  DRAFT
  SENT
  ACCEPTED
  REJECTED
  EXPIRED // e.g. if not accepted by expiryDate
  CANCELED // Manually canceled
}

model Quote {
  id              String      @id @default(uuid())
  tenantId        String
  quoteNumber     String // Auto-generated or manual, e.g., QT-2024-001
  opportunityId   String
  dateCreated     DateTime    @default(now())
  expiryDate      DateTime?
  status          QuoteStatus @default(DRAFT)
  totalAmount     Float // Calculated from line items
  notes           String?
  terms           String?
  createdByUserId String? // TenantUser who created it
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  deletedAt       DateTime?

  tenant        Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  opportunity   Opportunity     @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  createdByUser TenantUser?     @relation("QuoteCreatedByUser", fields: [createdByUserId], references: [id], onDelete: SetNull)
  lineItems     QuoteLineItem[]

  @@unique([tenantId, quoteNumber])
  @@index([opportunityId])
  @@index([tenantId, status])
}

model QuoteLineItem {
  id          String   @id @default(uuid())
  quoteId     String
  productId   String
  productName String // Denormalized from Product for historical accuracy
  description String? // Can be custom or from Product
  quantity    Int
  unitPrice   Float // Price at the time of quoting
  total       Float // quantity * unitPrice
  createdAt   DateTime @default(now())
  // No deletedAt, items are part of an immutable quote once sent

  quote   Quote   @relation(fields: [quoteId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Restrict) // Product cannot be deleted if part of a quote

  @@index([quoteId])
  @@index([productId])
}

// Task
enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  ARCHIVED
}

enum TaskPriority {
  HIGH
  MEDIUM
  LOW
}

model Task {
  id               String        @id @default(uuid())
  tenantId         String
  title            String
  description      String?
  status           TaskStatus    @default(PENDING)
  priority         TaskPriority? @default(MEDIUM)
  dueDate          DateTime?
  completedAt      DateTime?
  createdById      String? // TenantUser who created the task
  assignedToUserId String? // TenantUser assigned to the task
  opportunityId    String? // Link to Opportunity
  projectId        String? // Link to Project
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  deletedAt        DateTime?

  tenant      Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdBy   TenantUser?  @relation("TaskCreatedByUser", fields: [createdById], references: [id], onDelete: SetNull)
  assignedTo  TenantUser?  @relation("TaskAssignedToUser", fields: [assignedToUserId], references: [id], onDelete: SetNull)
  opportunity Opportunity? @relation("TaskForOpportunity", fields: [opportunityId], references: [id], onDelete: SetNull)
  project     Project?     @relation("TaskForProject", fields: [projectId], references: [id], onDelete: SetNull)
  tags        TaskTag[]

  @@index([tenantId, status, dueDate])
  @@index([assignedToUserId])
  @@index([opportunityId])
  @@index([projectId])
}

model TaskTag {
  taskId     String
  tagId      String
  assignedAt DateTime @default(now())

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([taskId, tagId])
}

// Project
enum ProjectStatus {
  PLANNING
  ACTIVE
  COMPLETED
  ON_HOLD
  CANCELED
}

model Project {
  id            String        @id @default(uuid())
  tenantId      String
  name          String
  description   String?
  status        ProjectStatus @default(PLANNING)
  startDate     DateTime?
  endDate       DateTime? // Planned end date
  actualEndDate DateTime? // Actual completion date
  opportunityId String?       @unique // Optional: If project originated from an opportunity
  companyId     String? // Optional: Client company
  notes         String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  deletedAt     DateTime?

  tenant      Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  opportunity Opportunity?        @relation(fields: [opportunityId], references: [id], onDelete: SetNull)
  company     Company?            @relation(fields: [companyId], references: [id], onDelete: SetNull)
  teamMembers ProjectTeamMember[]
  tasks       Task[]              @relation("TaskForProject")
  tags        ProjectTag[]

  @@index([tenantId, status])
  @@index([companyId])
}

model ProjectTag {
  projectId  String
  tagId      String
  assignedAt DateTime @default(now())

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  tag     Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([projectId, tagId])
}

// Junction table for Project and TenantUser (Many-to-Many for team members)
model ProjectTeamMember {
  projectId     String
  tenantUserId  String
  roleInProject String? // e.g., Project Manager, Developer, Designer
  assignedAt    DateTime @default(now())

  project    Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)

  @@id([projectId, tenantUserId])
}

// CHATBOT FLOW BUILDER
model ChatbotFlow {
  id             String    @id @default(uuid())
  tenantId       String
  name           String
  description    String?
  status         String    @default("DRAFT") // DRAFT, PUBLISHED, ARCHIVED
  flowDefinition Json // JSON representing the nodes and edges of the flow
  entryPoints    String[] // e.g., Specific channel IDs, keywords, or API triggers
  version        Int       @default(1)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  deletedAt      DateTime?

  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  chatMessages ChatMessage[] // Messages related to this flow execution (if storing flow specific messages)

  @@index([tenantId, status])
}

// SDK Chat Messages (if distinct from general conversation messages)
model ChatMessage {
  id          String    @id @default(uuid())
  sessionId   String // Unique ID for a specific chat session using the SDK
  flowId      String? // If linked to a specific ChatbotFlow
  sender      String // "user" or "bot"
  messageType String // TEXT, IMAGE, BUTTON_CLICK etc.
  content     Json // Message content (text, button payload, image URL etc.)
  timestamp   DateTime  @default(now())
  metadata    Json? // Additional metadata
  tenantId    String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  flow ChatbotFlow? @relation(fields: [flowId], references: [id], onDelete: SetNull)
  // No direct tenant relation here if flowId is always present and ChatbotFlow has tenantId
  // However, for standalone SDK messages not tied to a flow, tenantId would be good.
  // For now, assuming messages are linked to a flow or a general tenant context.

  @@index([sessionId, timestamp])
  @@index([flowId])
  @@index([tenantId]) // If storing tenantId directly on ChatMessage
}
