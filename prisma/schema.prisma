
datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

// Core Tenant and User Models
model Tenant {
  id                  String              @id @default(uuid())
  name                String
  subdomain           String              @unique
  logoUrl             String?
  primaryColor        String?
  secondaryColor      String?
  isActive            Boolean             @default(true)
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  deletedAt           DateTime?
  ownerId             String? // ID del User (de auth.users) que es el propietario original

  users               TenantUser[]
  roles               Role[]
  permissions         Permission[]
  notifications       Notification[]
  conversations       Conversation[]
  messages            Message[]
  leads               Lead[]
  tags                Tag[]
  contacts            Contact[]
  opportunities       Opportunity[]
  products            Product[]
  quotes              Quote[]
  tasks               Task[]
  projects            Project[]
  chatbotFlows        ChatbotFlow[]
  chatMessages        ChatMessage[]
  rolePermissions     RolePermission[] // Relación con la tabla de unión
  projectTeamMembers  ProjectTeamMember[]
  opportunityProducts OpportunityProduct[]
  quoteLineItems      QuoteLineItem[]
  taskTags            TaskTag[]
  projectTags         ProjectTag[]
  leadTags            LeadTag[]
}

model TenantUser {
  id                      String              @id @default(uuid())
  authUserId              String              @unique // Foreign key to Supabase auth.users.id
  tenantId                String
  roleId                  String
  fullName                String?
  email                   String              @unique // Ensure email is unique across TenantUsers for invites, etc.
  avatarUrl               String?
  isActive                Boolean             @default(true)
  lastLogin               DateTime?
  createdAt               DateTime            @default(now())
  updatedAt               DateTime            @updatedAt
  deletedAt               DateTime?

  tenant                  Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  role                    Role                @relation(fields: [roleId, tenantId], references: [id, tenantId], onDelete: Restrict) // Un usuario tiene un rol dentro de un tenant
  userSessions            UserSession[]
  notifications           Notification[]      @relation("NotificationToUser")
  assignedConversations   Conversation[]      @relation("AssignedConversationToUser")
  assignedLeads           Lead[]              @relation("LeadAssignedToUser")
  createdOpportunities    Opportunity[]       @relation("OpportunityCreator")
  assignedOpportunities   Opportunity[]       @relation("OpportunityAssignedToUser")
  createdQuotes           Quote[]             @relation("QuoteCreator")
  assignedTasks           Task[]              @relation("TaskAssignedToUser")
  ProjectTeamMember       ProjectTeamMember[]
}

model Role {
  id          String   @id @default(uuid())
  tenantId    String
  name        String   // e.g., "Administrator", "Agent", "Supervisor"
  description String?
  isSystemRole Boolean  @default(false) // True for predefined system roles, false for custom tenant roles
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime?

  tenant           Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  users            TenantUser[]       // Un rol puede tener muchos usuarios
  rolePermissions  RolePermission[]   // Relación con la tabla de unión

  @@unique([tenantId, name]) // Role name must be unique within a tenant
}

model Permission {
  id          String   @id @default(uuid())
  tenantId    String?  // Permisos pueden ser globales (tenantId=null) o específicos del tenant
  action      String   // e.g., "create", "read", "update", "delete", "manage"
  resource    String   // e.g., "Lead", "Conversation", "User", "Billing"
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime?

  tenant            Tenant?            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  rolePermissions   RolePermission[]   // Relación con la tabla de unión

  @@unique([action, resource, tenantId])
}

// Junction table for Role and Permission (Many-to-Many)
model RolePermission {
  roleId       String
  permissionId String
  tenantId     String   // To scope the RolePermission assignment to a tenant
  assignedAt   DateTime @default(now())

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId, tenantId])
}

model UserSession {
  id           String   @id @default(uuid())
  userId       String
  tenantUserId String   // ID del TenantUser
  token        String   @unique
  expiresAt    DateTime
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime @default(now())

  user TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
}

model Notification {
  id          String    @id @default(uuid())
  tenantId    String
  userId      String    // TenantUser ID
  title       String
  message     String
  isRead      Boolean   @default(false)
  link        String?   // Optional link to navigate to
  type        String?   // e.g., "new_lead", "task_reminder", "system_update"
  icon        String?   // Optional icon identifier
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  user   TenantUser @relation("NotificationToUser", fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
}

// Communication Models
enum ChannelType {
  WHATSAPP
  MESSENGER
  INSTAGRAM
  WEBCHAT // Renombrado de WEB_CHAT
  TELEGRAM
  API
}

model ConnectedChannel {
  id            String      @id @default(uuid())
  tenantId      String
  instanceName  String      // e.g., "Sales WhatsApp", "Support Web Chat"
  channelType   ChannelType
  status        String      // e.g., "connected", "disconnected", "needs_attention", "pending_webhook"
  webhookUrl    String?     @unique
  verifyToken   String?
  details       Json?       // Store specific config like API keys, Page IDs, Phone Number IDs
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  deletedAt     DateTime?

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
}

enum ConversationStatus {
  ACTIVE
  ASSIGNED
  CLOSED
  ARCHIVED
  // Valores antiguos como PENDING, RESOLVED, BOT, AGENT se eliminarán
  // Asegúrate de que no haya datos en la BD con esos valores antes de migrar
}

model Conversation {
  id                 String             @id @default(uuid())
  channel            ChannelType
  channelSpecificId  String?            // ID de la conversación en el canal específico (e.g., WhatsApp chat ID)
  userName           String             // Nombre del contacto/lead
  lastMessageSnippet String?
  avatarUrl          String?
  unreadCount        Int                @default(0)
  lastMessageAt      DateTime           @default(now())
  status             ConversationStatus @default(ACTIVE)
  assignedToUserId   String?
  tenantId           String
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  deletedAt          DateTime?

  assignedTo         TenantUser?      @relation("AssignedConversationToUser", fields: [assignedToUserId], references: [id], onDelete: SetNull)
  tenant             Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  messages           Message[]
  tags               ConversationTag[]

  @@unique([tenantId, channel, channelSpecificId])
}

enum MessageType {
  TEXT
  IMAGE
  PRODUCT
  INTERACTIVE // Para botones y listas. Se eliminan BUTTONS, LIST
  SYSTEM      // Mensajes generados por el sistema
  FILE
  AUDIO
  VIDEO
  LOCATION
  CONTACT
  TEMPLATE
}

enum MessageSender {
  USER
  AGENT
  BOT
  SYSTEM
}

model Message {
  id              String        @id @default(uuid())
  conversationId  String
  sender          MessageSender
  senderId        String?       // ID del TenantUser si sender es AGENT o BOT, o ID del usuario externo
  content         String?       // Text content
  type            MessageType
  timestamp       DateTime      @default(now())
  imageUrl        String?
  productName     String?
  productPrice    String?
  productDescription String?
  buttons         Json?         // Store button structure as JSON
  listItems       Json?         // Store list items structure as JSON
  metadata        Json?         // Para cualquier info adicional, e.g., message_id del proveedor
  isReadByAgent   Boolean       @default(false)
  tenantId        String
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  deletedAt       DateTime?

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  tenant       Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
}

// CRM Models
enum LeadSource {
  WHATSAPP
  WEBCHAT // Renombrado de WEB_CHAT
  MESSENGER
  INSTAGRAM
  MANUAL
  REFERRAL
  API
  FORM
  EMAIL
}

enum LeadStatus {
  NEW
  CONTACTED
  QUALIFIED
  PROPOSAL
  NEGOTIATION
  CONVERTED // CONVERTED_TO_OPPORTUNITY
  CLOSED_WON
  CLOSED_LOST
  UNQUALIFIED
}

model Lead {
  id               String      @id @default(uuid())
  tenantId         String
  name             String
  email            String?     @unique // Email debe ser único por tenant para evitar duplicados directos
  phone            String?
  companyName      String?
  source           LeadSource
  status           LeadStatus  @default(NEW)
  assignedToUserId String?
  lastContacted    DateTime?
  notes            String?
  potentialValue   Float?
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt
  deletedAt        DateTime?

  tenant           Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  assignedTo       TenantUser?   @relation("LeadAssignedToUser", fields: [assignedToUserId], references: [id], onDelete: SetNull)
  tags             LeadTag[]
  opportunities    Opportunity[] // Un lead puede convertirse en una o más oportunidades
  contacts         Contact[]     // Un lead puede tener múltiples puntos de contacto
}

model Tag {
  id        String   @id @default(uuid())
  tenantId  String
  name      String   // Tag name, e.g., "vip", "follow-up", "product_x_interest"
  color     String?  // Hex color for the tag, e.g., "#FF5733"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?

  tenant        Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  leadTags      LeadTag[]
  taskTags      TaskTag[]
  projectTags   ProjectTag[]
  conversationTags ConversationTag[]

  @@unique([tenantId, name])
}

model LeadTag {
  leadId    String
  tagId     String
  assignedAt DateTime @default(now())

  lead Lead @relation(fields: [leadId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([leadId, tagId])
}

model Contact {
  id            String   @id @default(uuid())
  tenantId      String
  leadId        String?  // Opcional, si el contacto se originó de un lead
  companyId     String?  // Opcional, si el contacto está asociado a una empresa
  firstName     String
  lastName      String?
  email         String?  @unique
  phonePrimary  String?
  phoneOther    String?
  jobTitle      String?
  addressStreet String?
  addressCity   String?
  addressState  String?
  addressPostalCode String?
  addressCountry String?
  description   String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  deletedAt     DateTime?

  tenant  Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  lead    Lead?    @relation(fields: [leadId], references: [id], onDelete: SetNull)
  company Company? @relation(fields: [companyId], references: [id], onDelete: SetNull)
}

model Company {
  id                String   @id @default(uuid())
  tenantId          String
  name              String
  email             String?  @unique // Company general email
  phone             String?
  website           String?
  addressStreet     String?
  addressCity       String?
  addressState      String?
  addressPostalCode String?
  addressCountry    String?
  description       String?
  industry          String?
  annualRevenue     Float?
  numberOfEmployees Int?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  deletedAt         DateTime?

  tenant    Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  contacts  Contact[] // Una empresa puede tener muchos contactos
  opportunities Opportunity[] // Una empresa puede tener muchas oportunidades
}

enum OpportunityStatus {
  QUALIFICATION
  PROPOSAL
  NEGOTIATION
  CLOSED_WON
  CLOSED_LOST
  ON_HOLD
}

model Opportunity {
  id               String            @id @default(uuid())
  tenantId         String
  name             String            // e.g., "Website Redesign for Acme Corp"
  leadId           String?           // Si se originó de un lead
  companyId        String?           // Empresa asociada
  status           OpportunityStatus @default(QUALIFICATION)
  estimatedValue   Float?
  closeDate        DateTime?         // Expected close date
  probability      Float?            // 0.0 to 1.0
  description      String?
  createdById      String
  assignedToUserId String?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  deletedAt        DateTime?

  tenant                Tenant                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  lead                  Lead?                  @relation(fields: [leadId], references: [id], onDelete: SetNull)
  company               Company?               @relation(fields: [companyId], references: [id], onDelete: SetNull)
  createdBy             TenantUser             @relation("OpportunityCreator", fields: [createdById], references: [id], onDelete:Restrict)
  assignedTo            TenantUser?            @relation("OpportunityAssignedToUser", fields: [assignedToUserId], references: [id], onDelete: SetNull)
  opportunityProducts   OpportunityProduct[]
  quotes                Quote[]
}

enum ProductType {
  PRODUCTO // Corregido de PRODUCT
  SERVICIO
}

model Product {
  id            String      @id @default(uuid())
  tenantId      String
  name          String
  type          ProductType @default(PRODUCTO) // PRODUCTO, SERVICIO
  description   String?
  price         Float
  sku           String?     @unique // Stock Keeping Unit, unique per tenant
  category      String?
  isActive      Boolean     @default(true)
  attributes    Json?       // e.g., {"color": "Red", "size": "M"}
  imageUrl      String?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  deletedAt     DateTime?

  tenant              Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  opportunityProducts OpportunityProduct[]
  quoteLineItems      QuoteLineItem[]
}

model OpportunityProduct {
  opportunityId String
  productId     String
  quantity      Int
  unitPrice     Float    // Price at the time of adding to opportunity
  totalPrice    Float
  notes         String?
  assignedAt DateTime @default(now())

  opportunity Opportunity @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  product     Product     @relation(fields: [productId], references: [id], onDelete: Restrict) // Restrict deletion of product if used
  tenant      Tenant      @relation(fields: [opportunityId, productId], references: [id, id]) // This relation might be complex due to composite key needs or just tenantId
  // Consider if tenant relation is needed here or inherited via Opportunity. For simplicity, removed direct tenant relation needing composite keys on Product for now.
  // If product is global, then direct tenantId on OpportunityProduct might be better.
  // Let's assume Product is tenant-specific, so relation to tenant comes via Opportunity.

  @@id([opportunityId, productId])
}

enum QuoteStatus {
  DRAFT     // BORRADOR
  SENT      // ENVIADA
  ACCEPTED  // ACEPTADA
  REJECTED  // RECHAZADA
  EXPIRED   // NUEVO, antes ANULADA o vencida
  CANCELED  // NUEVO, para cancelación explícita
}

model Quote {
  id              String      @id @default(uuid())
  tenantId        String
  quoteNumber     String      // e.g., QT-2024-001, unique per tenant
  opportunityId   String
  createdById     String
  issueDate       DateTime    @default(now())
  expiryDate      DateTime?
  status          QuoteStatus @default(DRAFT)
  totalAmount     Float
  notes           String?
  terms           String?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  deletedAt       DateTime?

  tenant        Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  opportunity   Opportunity     @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  createdBy     TenantUser      @relation("QuoteCreator", fields: [createdById], references: [id], onDelete: Restrict)
  lineItems     QuoteLineItem[]

  @@unique([tenantId, quoteNumber])
}

model QuoteLineItem {
  id          String   @id @default(uuid())
  quoteId     String
  productId   String
  productName String   // Snapshot of product name at time of quote
  description String?  // Snapshot of product description
  quantity    Int
  unitPrice   Float    // Snapshot of unit price
  total       Float
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime? // Soft delete for line items if needed

  quote   Quote  @relation(fields: [quoteId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)
  tenant  Tenant @relation(fields: [quoteId, productId], references: [id, id]) // Similar complexity as OpportunityProduct
  // Again, tenant relation inherited is simpler.
}

enum TaskStatus {
  PENDING     // PENDIENTE
  IN_PROGRESS // EN_PROGRESO
  COMPLETED   // COMPLETADA
  ARCHIVED    // ARCHIVADA
}

enum TaskPriority {
  HIGH
  MEDIUM
  LOW
}

model Task {
  id               String        @id @default(uuid())
  tenantId         String
  title            String
  description      String?
  status           TaskStatus    @default(PENDING)
  priority         TaskPriority? @default(MEDIUM)
  dueDate          DateTime?
  completedAt      DateTime?
  assignedToUserId String?
  relatedToType    String?       // e.g., "Lead", "Opportunity", "Project", "Company"
  relatedToId      String?       // ID of the related entity
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  deletedAt        DateTime?

  tenant     Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  assignee   TenantUser? @relation("TaskAssignedToUser", fields: [assignedToUserId], references: [id], onDelete: SetNull)
  tags       TaskTag[]
}

model TaskTag {
  taskId    String
  tagId     String
  assignedAt DateTime @default(now())

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([taskId, tagId])
}

enum ProjectStatus {
  PLANNING    // PLANIFICACION
  ACTIVE      // ACTIVO
  COMPLETED   // COMPLETADO
  ON_HOLD     // EN_ESPERA
  CANCELED    // CANCELADO
}

model Project {
  id              String        @id @default(uuid())
  tenantId        String
  name            String
  description     String?
  status          ProjectStatus @default(PLANNING)
  startDate       DateTime?
  endDate         DateTime?     // Planned end date
  actualEndDate   DateTime?     // Actual end date
  budget          Float?
  opportunityId   String?       @unique // Si el proyecto se originó de una oportunidad
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  deletedAt       DateTime?

  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  opportunity   Opportunity?        @relation(fields: [opportunityId], references: [id], onDelete: SetNull)
  tags          ProjectTag[]
  teamMembers   ProjectTeamMember[]
}

model ProjectTag {
  projectId String
  tagId     String
  assignedAt DateTime @default(now())

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  tag     Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([projectId, tagId])
}

model ProjectTeamMember {
  projectId    String
  tenantUserId String
  roleInProject String?  // e.g., "Project Manager", "Developer"
  assignedAt   DateTime @default(now())

  project      Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user         TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
  tenant       Tenant     @relation(fields: [tenantUserId, projectId], references: [id, id]) // Inherited tenant

  @@id([projectId, tenantUserId])
}

// Flow Builder & SDK Models
model ChatbotFlow {
  id             String   @id @default(uuid())
  tenantId       String
  name           String
  description    String?
  definitionJson Json     // Stores the ReactFlow JSON definition
  status         String   // e.g., "DRAFT", "PUBLISHED", "ARCHIVED"
  version        Int      @default(1)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  deletedAt      DateTime?

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
}

model ChatMessage {
  id           String   @id @default(uuid()) // From SDK
  tenantId     String
  sessionId    String   // Unique session ID for the chat on the website
  visitorId    String   // Unique ID for the website visitor
  senderType   String   // "visitor" or "bot" or "agent"
  messageText  String?
  messageType  String   // "text", "image", "button_click"
  payload      Json?    // For button clicks or other structured data
  timestamp    DateTime @default(now())
  isReadByAgent Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  deletedAt    DateTime?

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([visitorId])
}

model ConversationTag {
  conversationId String
  tagId          String
  assignedAt     DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  tag          Tag          @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([conversationId, tagId])
}
